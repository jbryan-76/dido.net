- enhance Run() configuration or parameters to support the application creating custom communication channels
  (and corresponding symmetric capability on the execution context)
- add progress support to execution context
- create Dido.Mediator from Dido.Runner and use MediatorServer
- create Dockerfile.Mediator.build
- create Dockerfile.Mediator.pack
- create jobs system with mediator, including configurable optional persistence
- explore task "tethering": what should a task running on a runner do when the application connection terminates
  unexpectedly? also terminate? keep going and store result on a mediator? can we support re-establishing a connection?
  when an app tries reconnecting to an untethered task:
    case fail: the app will need to start the task over
    case succeed:
       case task failed: the app will receive the error and can retry as needed
       case task nominal: the app can communicate normally
  when starting an untethered task, return a "handle" object. use the handle to interact with the task: messages, stop/cancel.
  later, the application can stop/start again, then "connect" to an existing untethered task via: runner uri/id and task id
  and get back a handle.
- explore supporting fire-and-forget tasks, also with dynamic reconnection? this would enable eg microservice patterns.
  however what does it mean for following use case?
    1) application starts an untethered microservice task
    2) application stops (microservice task keeps running)
    3) application updates the microservice code
    4) application restarts and reconnects to the microservice task
    =>) if code has changed (? how to tell?), stop task, unload assemblies, restart task
- for "untethered" tasks, force the use of an external durable message system rather than write out own? can be achieved 
  through configuration and delegates or plugins.